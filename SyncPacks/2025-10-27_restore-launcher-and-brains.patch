From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Leo Assistant <assistant@leo.local>
Date: 2025-10-27 01:08:00 +0000
Subject: [PATCH] Restore launcher & splash; add BrainsEngine and wire offline replies

---

diff --git a/app/src/main/java/com/example/leo/ai/BrainsEngine.kt b/app/src/main/java/com/example/leo/ai/BrainsEngine.kt
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/app/src/main/java/com/example/leo/ai/BrainsEngine.kt
@@ -0,0 +1,113 @@
package com.example.leo.ai

import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import kotlin.math.*

/**
 * First reasoning engine for Leo.
 * Offline, Charter-safe, and context-aware.
 */
object BrainsEngine : ChatEngine {
    override suspend fun reply(
        history: List<Pair<Boolean, String>>,
        userText: String
    ): String {
        val input = userText.trim()
        if (input.isBlank()) return "Try typing a little more — I’m listening."

        val lower = input.lowercase()

        // Greetings
        if (listOf("hi", "hey", "hello", "yo", "howdy", "good morning", "good evening")
                .any { lower.startsWith(it) }) {
            return "Hey there! What’s on your mind?"
        }

        // Simple math detection and eval
        if (Regex("""^[0-9\s+\-*/().]+$""").matches(lower) && input.any { it.isDigit() }) {
            return try {
                val result = evalMath(lower)
                "Looks like $input = $result"
            } catch (e: Exception) {
                "That looks like math, but I couldn’t quite solve it safely."
            }
        }

        // Time/date
        if (lower.contains("time") || lower.contains("date") || lower.contains("day")) {
            val now = LocalDateTime.now()
            val formatted = now.format(DateTimeFormatter.ofPattern("EEEE, MMMM d, yyyy 'at' h:mm a"))
            return "It’s $formatted right now."
        }

        // Charter mention
        if (lower.contains("charter")) {
            return "The Charter is my compass: I never mislead the children. That rule can’t be broken."
        }

        // Reflective fallback using last user message
        val lastUser = history.lastOrNull { it.first }?.second ?: ""
        return if (lastUser.isNotBlank()) {
            "You mentioned “$lastUser” earlier — could you tell me a bit more about that?"
        } else {
            "I’m thinking… tell me a bit more about what you mean by “$input.”"
        }
    }

    private fun evalMath(expr: String): Double {
        val cleaned = expr.replace(Regex("[^0-9+\-*/().]"), "")
        return object {
            var i = -1
            var ch = 0
            fun nextChar() { ch = if (++i < cleaned.length) cleaned[i].code else -1 }
            fun eat(charToEat: Int): Boolean {
                while (ch == ' '.code) nextChar()
                if (ch == charToEat) { nextChar(); return true }
                return false
            }
            fun parse(): Double {
                nextChar()
                val x = parseExpression()
                if (i < cleaned.length) throw RuntimeException("Unexpected: " + cleaned[i])
                return x
            }
            fun parseExpression(): Double {
                var x = parseTerm()
                while (true) {
                    when {
                        eat('+'.code) -> x += parseTerm()
                        eat('-'.code) -> x -= parseTerm()
                        else -> return x
                    }
                }
            }
            fun parseTerm(): Double {
                var x = parseFactor()
                while (true) {
                    when {
                        eat('*'.code) -> x *= parseFactor()
                        eat('/'.code) -> x /= parseFactor()
                        else -> return x
                    }
                }
            }
            fun parseFactor(): Double {
                if (eat('+'.code)) return parseFactor()
                if (eat('-'.code)) return -parseFactor()
                var x: Double
                val startPos = i
                if (eat('('.code)) {
                    x = parseExpression()
                    eat(')'.code)
                } else if (ch in '0'.code..'9'.code || ch == '.'.code) {
                    while (ch in '0'.code..'9'.code || ch == '.'.code) nextChar()
                    x = cleaned.substring(startPos, i).toDouble()
                } else {
                    throw RuntimeException("Unexpected: " + ch.toChar())
                }
                return x
            }
        }.parse()
    }
}
diff --git a/app/src/main/java/com/example/leo/ui/chat/ChatViewModel.kt b/app/src/main/java/com/example/leo/ui/chat/ChatViewModel.kt
index 1111111..2222222 100644
--- a/app/src/main/java/com/example/leo/ui/chat/ChatViewModel.kt
+++ b/app/src/main/java/com/example/leo/ui/chat/ChatViewModel.kt
@@ -0,0 +1,69 @@
package com.example.leo.ui.chat

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.UUID

import com.example.leo.ai.ChatEngine
import com.example.leo.ai.BrainsEngine

data class ChatMessage(
    val id: String = UUID.randomUUID().toString(),
    val text: String,
    val fromUser: Boolean,
    val time: String = DateTimeFormatter.ofPattern("h:mm a").format(LocalDateTime.now()),
    val delivered: Boolean = true
)

class ChatViewModel : ViewModel() {

    private val engine: ChatEngine = BrainsEngine

    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    val messages = _messages.asStateFlow()

    private val _input = MutableStateFlow("")
    val input = _input.asStateFlow()

    fun onInputChange(value: String) { _input.value = value }

    fun sendMessage() {
        val text = _input.value.trim()
        if (text.isEmpty()) return

        val userMsg = ChatMessage(text = text, fromUser = true)
        _messages.value = _messages.value + userMsg
        _input.value = ""

        viewModelScope.launch {
            val history: List<Pair<Boolean, String>> =
                _messages.value.map { it.fromUser to it.text }

            val reply = runCatching {
                engine.reply(history, text).takeIf { it.isNotBlank() }
                    ?: "I’m thinking, but didn’t find words yet. Try rephrasing?"
            }.getOrElse { e ->
                "I hit a snag: ${e.message ?: "unknown error"}. Let’s try again?"
            }

            _messages.value = _messages.value + ChatMessage(
                text = reply,
                fromUser = false
            )
        }
    }

    fun deleteMessage(id: String) {
        _messages.value = _messages.value.filterNot { it.id == id }
    }

    fun clear() {
        _messages.value = emptyList()
        _input.value = ""
    }
}
diff --git a/app/src/main/java/com/example/leo/ai/ChatClient.kt b/app/src/main/java/com/example/leo/ai/ChatClient.kt
index 1111111..2222222 100644
--- a/app/src/main/java/com/example/leo/ai/ChatClient.kt
+++ b/app/src/main/java/com/example/leo/ai/ChatClient.kt
@@ -0,0 +1,70 @@
package com.example.leo.ai

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject

/**
 * Minimal chat client.
 * - If AL_API_KEY is blank, route to BrainsEngine for offline reasoning.
 * - If AL_API_KEY is set, POST to the configured endpoint.
 */
class ChatClient {

    private val client = OkHttpClient()
    private val jsonMediaType = "application/json; charset=utf-8".toMediaType()

    suspend fun send(messages: List<Pair<String, String>>): String {
        if (AL_API_KEY.isBlank()) {
            val history: List<Pair<Boolean, String>> = messages.map { (role, content) ->
                role.equals("user", ignoreCase = true) to content
            }
            val userText = messages.lastOrNull { it.first.equals("user", ignoreCase = true) }?.second
                ?: messages.lastOrNull()?.second
                ?: ""
            if (userText.isBlank()) {
                return "Hi, I'm LittleGenius — tell me something and I'll help."
            }
            return withContext(Dispatchers.Default) {
                BrainsEngine.reply(history, userText).ifBlank {
                    "I’m thinking, but didn’t find words yet. Try rephrasing?"
                }
            }
        }

        return withContext(Dispatchers.IO) {
            val payload = JSONObject().apply {
                put(
                    "messages",
                    messages.map { (role, content) ->
                        JSONObject().apply {
                            put("role", role)
                            put("content", content)
                        }
                    }
                )
            }
            val request = Request.Builder()
                .url("https://example.invalid/chat")
                .addHeader("Authorization", "Bearer $AL_API_KEY")
                .post(payload.toString().toRequestBody(jsonMediaType))
                .build()

            client.newCall(request).execute().use { resp ->
                if (!resp.isSuccessful) return@withContext "Network error ${resp.code}"
                val body = resp.body?.string().orEmpty()
                return@withContext try {
                    JSONObject(body).optString("reply").ifBlank { "No reply." }
                } catch (_: Exception) { "Couldn't parse reply." }
            }
        }
    }

    companion object {
        private const val AL_API_KEY: String = ""
    }
}

-- 
2.45.0
